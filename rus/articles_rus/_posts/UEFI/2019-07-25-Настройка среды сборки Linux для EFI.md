---
title: Настройка среды сборки Linux для EFI
layout: post
tags:
  - uefi_rus
published: true
---
# Оглавление
{:.no_toc}

* toc
{:toc}

# Специфичные детали конфигурации Ubuntu

На этой странице не будет подробно рассказано, как установить Ubuntu или создать виртуальную машину Ubuntu, мы сосредоточимся на нескольких способах настройки компьютера Ubuntu, прежде чем можно будет установить и настроить UDK.

После того, как ты настроил Ubuntu для правильной работы, выполни следующие команды, чтобы обновить  пакеты и загрузить те, которые необходимы для UDK.

~~~
sudo apt-get update
sudo apt-get upgrade
sudo apt-get install build-essential uuid-dev iasl nasm git
~~~

На этом этапе у тебя должны быть все зависимости для UDK, которые не включены в сам пакет UDK, и ты готов установить UDK.

# Установка UDK

Первым шагом в настройке среды разработки является установка UDK, в данном случае TianoCore EDK II : [https://github.com/tianocore/tianocore.github.io/wiki/EDK-II](https://github.com/tianocore/tianocore.github.io/wiki/EDK-II). Это среда с открытым исходным кодом для разработки UEFI и PI.

~~~
mkdir ~/src
cd ~/src
git clone https://github.com/tianocore/edk2
cd edk2
make -C Basetools/
export EDK_TOOLS_PATH=$HOME/src/edk2/BaseTools
mkdir Conf
. edksetup.sh BaseTools 
~~~

Если всё удалось, вывод должен быть похож на следующий:

~~~
bash$. edksetup.sh BaseTools
WORKSPACE: /home/user/src/edk2
EDK_TOOLS_PATH: /home/user/src/edk2/BaseTools
Copying $EDK_TOOLS_PATH/Conf/build_rule.template
	to $WORKSPACE/Conf/Build_rule.txt
Copying $EDK_TOOLS_PATH/Conf/tools_def.template
	to $WORKSPACE/Conf/tools_def.txt
Copying $EDK_TOOLS_PATH/Conf/target.template
	to $WORKSPACE/Conf/target.txt
~~~

На этом этапе были создали компоненты BaseTools и настроена среда оболочки сборки. Следующим шагом является настройка установки для использования правильного компилятора GCC. Сначала определи свою версию GCC, используя команду ниже.

~~~
bash$ gcc --version
gcc (Ubuntu4.9.2-10ubuntu13) 4.9.2
Copyright (C) 2014 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE
~~~

Согласно вышеприведенному выводу, машина использует версию GCC 4.9.2. В целях конфигурации это будет упоминаться как «GCC49».

Затем, открой Conf/target.txt файл и найди следущие строки:

~~~
ACTIVE_PLATFORM		=Nt32Pkg/Nt32Pkg.dsc
TOOL_CHAIN_TAG		=MYTOOLS
TARGET_ARCH			=IA32
~~~

И измени их на следующее:

~~~
ACTIVE_PLATFORM		=MdeModulePkg/MdeModulePkg.dsc
TOOL_CHAIN_TAG		=GCC49
TARGET_ARCH			=IA32 X64
~~~

Примечание: если на твоём компьютере с Ubuntu установлена другая версия GCC, используй свой номер вместо GCC49.

Теперь нужно построить проект. Команда и некоторые ее результаты приведены ниже. 
Примечание: дай себе несколько минут отдыха, так как команда займет немного времени.

~~~
bash$cd ~/src/edk2
bash$build
Build environment: Linux-3.19.0-15-generic-x86_64-with-Ubuntu-15.04-vivid
Build start time: 14:18:08, Aug.11 2015
WORKSPACE        = /home/user/src/edk2
ECP_SOURCE       = /home/user/src/edk2/EdkCompatibilityPkg
EDK_SOURCE       = /home/user/src/edk2/EdkCompatibilityPkg
EFI_SOURCE       = /home/user/src/edk2/EdkCompatibilityPkg
EDK_TOOLS_PATH   = /home/user/src/edk2/BaseTools
Architecture(s)  = IA32 X64
Build target     = DEBUG
Toolchain        = GCC49
Active Platform          = /home/user/src/edk2/MdeModulePkg/MdeModulePkg.dsc
Processing meta-data ....


<LOTS OF MAKEFILE AND OTHER BUILD OUTPUT HERE>


- Done -
Build end time: 13:51:03, Aug.11 2015
Build total time: 00:06:34
bash$
~~~

Еще одно замечание: если вы получили ошибку «No command 'build' found», перезапустите скрипт edksetup.sh. Команда для этого: '. Edksetup.sh' Обязательно используйте '.' в начале команды, или она не будет работать.

На данный момент, предполагая, что сборка не выдает никаких ошибок, ты успешно создал среду сборки для EDK II. Следующим шагом является понимание того, как создать базовый исполняемый файл EFI, что будет описано в следующем разделе.

# Создание и сборка базового пакета EFI

В этом подразделе ты узнаешь, как создать базовую EFI-программу в стиле «HelloWorld», и как использовать EDK2 для ее создания.

## Пакет EFI и его компоненты

Основная структура сборки EDK II сосредоточена вокруг пакетов, которые используются для хранения нескольких модулей (которые в конечном итоге встроены в исполняемые файлы EFI).

## Использование мастера драйверов UEFI для создания нового пакета

Мастер драйверов UEFI - это инструмент, созданный Tianocore (теми же людьми, которые опубликовали EDK II), предназначенный для облегчения создания новых драйверов и пакетов EFI. Он автоматизирует некоторые из основных задач, которые вам необходимо выполнить, чтобы создать новый пакет.

Исходники можно найти вот тут [https://svn.code.sf.net/p/edk2share/code/trunk/DriverDeveloper/UefiDriverWizard](https://svn.code.sf.net/p/edk2share/code/trunk/DriverDeveloper/UefiDriverWizard), а краткое описание можно нати вот тут [https://github.com/tianocore/tianocore.github.io/wiki/UEFI-Driver-Wizard](https://github.com/tianocore/tianocore.github.io/wiki/UEFI-Driver-Wizard).

Настроить мастер установки драйверов очень просто: используй Subversion для проверки кода, создай каталог на компьютере с Ubuntu для всего этого, и скопируй "мастера" туда. Затем перейди в этот каталог и запусти скрипт launch.py, который запустит графический интерфейс.

Предполагая, что ты хранишь код мастера драйверов в папке src, которую ты создал выше, и что твой код изначально находился в ~/Downloads/UefiDriverWizard, команды для выполнения всего этого следующие:

~~~
cp -r ~/Downloads/UefiDriverWizard ~/src/
cd ~/src/UefiDriverWizard
python launch.py
~~~

Отсюда запускается графический интерфейс. Первый шаг - перейти в меню мастера драйверов UEFI и выбрать «Открыть рабочее пространство». Это позволит мастеру использовать ранее настроенную рабочую область, а именно «~/src/edk2». Выбери эту папку и нажми «Открыть».

Теперь мастер настроен на использование рабочего пространства. Следующим шагом является создание нового пакета, используя File-> New Package. Это откроет диалоговое окно, которое позволит определить имя, GUID пакета, версию пакета и GUID платформы для твоего пакета.

Ниже приведен скриншот с опциями, которые я использовал. Примечание: ваши GUID могут отличаться от моих. Это нормально, поскольку GUID по своей природе генерируются случайным образом, и это пошаговое руководство не будет ссылаться на GUID по его фактическому номеру.

![1]({{ site.baseurl }}/assets/img/posts/Screen Shot 2015-08-14.png){:class="imghalf"}

Once you have entered the package path, name, and version (the last part of the path and the name should be identical), hit "Finish".

This will generate the package declaration file (HelloEfi.dec) and the build description file (HelloEfi.dsc.) We will refer back to the dsc file once we are almost ready to build the executable at the end.

For now, we will move on to creating the Hello World C file and work through adding it to the package.

## Your Source: HelloEfi.c and Your Build Information: HelloEfi.inf

The first step in creating your source file(s) is to set up the package directory structure. Although the wizard did a lot of this for you, there is still a small amount to do to set up the package in a similar manner to those provided as part of EDK II.

The following commands will set up the directories as needed. The commands assume that your package name and path are identical to those in the screenshot above.

~~~
cd ~/src/edk2/HelloEfi
mkdir Library
mkdir Library/HelloEfi
cd Library/HelloEfi
~~~

Once you are in the Library/HelloEfi directory, it is time for you to create your C file, HelloEfi.c

Feel free to mess around with this file if you want to try more complicated things, otherwise, the source for this file is below:

~~~
/** @file
    This is a basic Hello World EFI program
**/
#include <Uefi.h>
#include <Library/UefiApplicationEntryPoint.h>
#include <Library/UefiLib.h>
EFI_STATUS
EFIAPI
UefiMain (
  IN EFI_HANDLE            ImageHandle,
  IN EFI_SYSTEM_TABLE     *SystemTable
)   
{
    Print(L"Hello EFI! \n");
    return EFI_SUCCESS;
}
~~~

This code has three #includes. However, the header files that they refer to are not included in the HelloEfi package. Instead, they are part of the MdePkg, the main package provided as part of EDK II.

In order to configure your HelloEfi package to know where those header files are and to know which of those includes are library classes, you will need to create the build information (INF) file.

Similarly to the C file, this file will be located in HelloEfi/Library/HelloEfi/ and named HelloEfi.inf . Its source is below:

~~~
##
#    Inf file for HelloEfi.efi
##

[Defines]
    INF_VERSION            =0x00010005
    BASE_NAME              =HelloEfi
    FILE_GUID              =ef6a784a-f1ee-4f75-ac0b-ba8f0869a2f2
    MODULE_TYPE            =UEFI_APPLICATION
    VERSION_STRING         =0.1
    ENTRY_POINT            =UefiMain

[Sources]
    HelloEfi.c

[Packages]
    MdePkg/MdePkg.dec

[LibraryClasses]
    UefiApplicationEntryPoint
    UefiLib

[Guids]

[Ppis]

[Protocols]

[FeaturePcd]

[Pcd]
~~~

At this point, you now have your source C code and your build information for that particular executable. The next step is to add that .inf file to your build description file for the entire package.

## DSC: Build Description File

HelloEfi.dsc, located in ~/src/edk2/HelloEfi/ , is the build description file for the entire package. This file defines information such as naming and version number for the package, as well as naming its imported library classes and the components to build from within the package itself. The UEFI Driver wizard created most of this file for you earlier, so now the only thing to modify is the [Components]  section to add your new HelloEfi.inf file.

In order to do this, open up HelloEfi.dsc in your favorite text editor and scroll down to the [Components] section. In that section, add the path from your edk2 folder to the inf file, as shown below:

~~~
<the LibraryClasses section ends>

[Components]
  # THE LINE BELOW IS WHAT YOU NEED TO ADD
  HelloEfi/Library/HelloEfi/HelloEfi.inf
  # ADD THE LINE ABOVE
~~~

As a side note: one concern with the driver wizard is that it is configured to using DOS/Windows newline characters. That means that if you open up the DSC file in Vim, you will see that the file is in DOS format, and Vim will render a "^M" character at the end of each line.

You will need to fix this so your package can be parsed properly on your Ubuntu system. You can either manually delete each of the "^M" characters, or, in VIm, type the following command:

~~~
:%s/^M//g
~~~

In order to get the proper "^M", you need to type CTRL + V, then CTRL + M. Typing "^M" will make it search for those literal characters, not 0xD.

Now that you have your DSC file formatted for Unix and pointing to your INF file, you are ready to build!

## Building the Package and Locating the Executable

Navigate back to the edk2 directory, and run the following commands to build your package and navigate to the folder where your EFI executable is placed.

~~~
. edksetup.sh
build -p HelloEfi/HelloEfi.dsc
cd Build/HelloEfi/Debug_GCC49/X64
<HelloEfi.efi is in this directory!>
~~~

# Building EFIs from the PocPkg Directory within the QuarkMatter Repo

The next step is to understand how to build code from the QuarkMatter repo within the UDK. One possible solution would be to place the clone of the QuarkMatter repo within a subdirectory of your EDK root (~/src/edk2). However, in order to make it easier to deal with using git (instead of having to populate the .gitignore with all of the other files that are built), we will instead place symbolic links in the UDK root directory and then build off of those links.

 

In order to make the links and build the package, you will need to run the following commands:

~~~
cp -rs /$PATHTOQUARKMATTER/quarkmatter/PocPkg /home/user/src/edk2/  #Create the symbolic links
cd /home/user/src/edk2				#Navigate to the edk2 directory for build
. edksetup.sh					#Make sure the environment variables are set properly
build -p PocPkg/PocPkg.dsc			#Build the package as if the source was actually in the edk2 directory tree
cd Build/PocPkg/Debug_GCC49/X64			#Navigate to the location of the resulting EFI binaries
~~~

This process can be applied to any other packages that are not in the edk2 directory that you want to build.
