---
title: CLSIDs и Соединительные Папки
layout: post
categories: articles
tags:
  - articles_rus
  - windows
published: true
---

# Оглавление
{:.no_toc}

* toc
{:toc}

# Соединительные папки

Соединительная папка в Windows - это метод, при котором пользователь может вызвать перенаправление в другую папку, обычно в другую известную папку. Соединительная папка считается жесткой ссылкой. Существует несколько способов создания соединительных папок. Модификация реестра может повлечь за собой создание такой папки. Другой способ - это запись desktop.ini внутри папки. Третий, и, вероятно, самый полезный для нас, это метод который является только соглашением об именах. Метод заключается в том, чтобы просто создать папку как таковую. MyFolder.{CLSID папки, с которой вы хотите "соединиться"}. После того как вы назвали папку таким образом, двойной щелчок по ней приведет вас к известной папке, представленной CLSID. Microsoft дает вам много примеров работы такого подхода. Таким образом, вы можете легко создать папку которая "соединяется" с "Панелью управления (все задачи)" и называть ее "Моя панель управления". Вы также можете применять эту технику к изображениями, документам, Internet Explorer, Мой Компьютер. Все эти специальные папки были назначены уникальные CLSID. Смотреть в CLSID установленные по умолчанию в Windows. Ниже приведен пример папки подключения к "Панели управления (все задачи)". Кроме того, если вы не знакомы с CLSID, см. [Что такое ключ реестра CLSID]({{ site.baseurl }}/articles/What-is-a-CLSID-Registry-Key/ "What is a CLSID Registry Key")


![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-6.png){:class="imgsquire"}


Имя папки "My Control Panel".{ED7BA470-8E54-465E-825C-99712043E01C} для перехода к панели управления.

![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-68.png){:class="imgsquire"}

![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-64.png){:class="imgsquire"}



Windows достаточно удобно скроет CLSID для вас.

![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-1.png){:class="imghalf"}

Соединение работает!
<br>

И что? 

Что происходит, когда CLSID не соответствует ожидаемым папкам? Что если это вообще не папка? Вот где это становится немного интересным.


# CLSIDs и COM Объекты

Используя CreateGuid я сгенерировал новый GUID {24138469-5DDA-479D-A150-3695B9365DC0}.  

![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-2.png){:class="imgsquire"}

добавьте CLSID, и мы получим это.

![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-3.png){:class="imgsquire"}
<br>
CLSID не становится скрытым, если не с чем его соотнести. Когда вы перемещаетесь в папку, она выглядит как обычная папка. Однако, если вы посмотрите Procmon, вы увидите это:

![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-7.png){:class="img"}

Из информации Procmon вы можете видеть, что навигация внутри папки заставляет проводник искать этот CLSID в HKEY_CURRENT_USER. По умолчанию подавляющее большинство CLSID хранятся в HKEY_LOCAL_MACHINE, но CLSID в HKEY_CURRENT_USER могут все еще использоваться. Итак, теперь давайте настроим наш ключ.

<br><br>
До:<br>
![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-9.png){:class="imgsquire"}

Добавленны записи:
По умолчанию, {24138469-5DDA-479D-A150-3695B9365DC0} - это ключ имени COM объекта:<br>
![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-11.png){:class="imghalf"}

Значения ключа InProcServer32:<br>
![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-12.png){:class="imghalf"}

Теперь, когда мы перемещаемся в нашей соединительной папке, мы видим:
Значения ключа InProcServer32:
![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-13.png){:class="imghalf"}
<br><br>
Выполнение происходит, когда verclsid.exe вызывает присоединение процесса на нашей DLL. Найс.

# Закрепление на уровне пользователя
К сожалению, похоже что это больше механизм закрепления в системе, чем вектор выполнения кода. Главным образом, потому что это потребовало бы и записи реестра и навигации в соединенительной папке. Рассматривая его как механизм закрепления, все что нам нужно сделать это установить ключи реестра и создать папку соединения в месте, в которое (или в дочернюю папку) проводник (или другой пользовательский процесс) будет перемещаться при запуске. Желательно, чтобы проводник перемещался в соеденительную папку. Мы могли бы сделать это с помощью библиотечных файлов в Windows 7+ (см. Windows Library Files (.library-ms)). Для более широкого охвата, используя ту же технику, я в конечном итоге заглянул в папки, в которых находилось «меню Пуск». Они загружаются в начале, они уже существуют, они существуют в AppData, и их чаще всего просматривают через меню «Пуск».

Unfortunately, this is probably a better persistence mechanism than execution vector. Mostly, because it would require both a registry write and navigation into the junction folder. When looking at it as a persistence mechanism, all we have to do is set the registry keys, and create the junction folder in a location that explorer (or some other user process) will navigate into/under on startup. Preferrably we would like explorer to navigate into the junction folder. We could do this with Library Files on Windows 7+ (see Windows Library Files (.library-ms) ). For wider coverage using the same technique, I ended up looking into folders navigated for the "start menu". They get loaded at the start, they already exist, they exist in AppData, and they are most often viewed through the start menu. 

So, navigate into %appdata%\Microsoft\Windows\Start Menu and you should see directories under the start menu, all should get navigated on login. However, you have to be careful when modifying any of these folders as they are often combined with folders in another location for the start menu and it could be alerting if there are two folders named Accessories in the targets start menu. If desired, you can also create a new folder vs using an already existing one. Anyways, so now takes something like Accessories.


![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-14.png){:class="imghalf"}


Run a command like below to change the folder to a junction folder (use windows api if coding).


![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-15.png){:class="imghalf"}


and note that on reboot, we are once again kicked off by verclsid.exe.


![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-22.png)
{:class="imghalf"}


# Persisting a Dll like an Exe - Windows Run

This is not yet a flushed out technique and is currently in proof-of-concept stage.

Currently, there are a select set of CLSIDs (yet to be determined what makes them different - current assumption is that there are additional registry entries needed), that can be accesssed through cmds Windows->run. The syntax looks something like:


![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-16.png)
{:class="imghalf"}


or


![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-17.png)
{:class="imghalf"}



These examples open up the "My Documents" folder in windows explorer. However, if the right entries are made, these could help us reuse exe persistence techniques for dlls.

# Shortcut Folders + Junction Folders + Libraries + Link Files = Exploitation

Let's combine some of these finds and put them to use. For background on libraries, see Windows Library Files (.library-ms).

So, if we have a link file exploit, we would like to hide it. Or at least bury it. We also know from playing around with CLSIDs and Junction folders that we can force navigation of a junction folder (enough rendering to get it to load a dll if the clsid is in the registry). Another nice thing about libraries is that they can look pretty similar to a directory and they continue rendering even if the explorer view was changed while rendering was still in process. We'll combine some of these things with a technique used by TAO in which a desktop.ini version of the junction folder is used to kick off the rendering of the link file. This brought up a very unique CLSID ({0AFACED1-E828-11D1-9187-B532F1E9575D}) which is the CLSID for a "Shortcut Folder". So what happens when you create the junction, MyFolder.{0AFACED1-E828-11D1-9187-B532F1E9575D}? Well, Microsoft designed Shortcut Folders to store its target in a target.lnk file directly below the junction folder. When the junction folder is navigated, the link file is rendered and execution is gained. The combination means that only the library file is visible in the directory the target navigates to, and all the other folders/file can be system, hidden. Do not use the technique without the library files unless permission is granted. We don't want to appear too close to TAO's technique. 

# Persisting in Explorer Using Junctions and Shell Folders (Walk-Through)

If you don't wish to be persisted by verclsid, you can add a couple extra entries to make sure that it is explorer that loads you instead. To setup this persistence technique you must:

 

Set the following registry keys in either HKEY_LOCAL_MACHINE or HKEY_CURRENT_USER (keeping in mind 64-bit and 32-bit registries):





Create:

| Key           | Name          | Value         | Notes         |
| :---------------------------------- | :-----------  | :-----------  | :-----------  |
| SOFTWARE\Classes\CLSID  | | | This has not always been created in HKEY_CURRENT_USER |
| SOFTWARE\Classes\CLSID\<CLSID>  | | | Create your own CLSID, not one that is already being used on the system |
| SOFTWARE\Classes\CLSID\<CLSID>  |(Default)| Name of Class |This is optional. Many classes have names |  	 
| SOFTWARE\Classes\CLSID\<CLSID>\InProcServer32                                   
|
| SOFTWARE\Classes\CLSID\<CLSID>\InProcServer32 | (Default) | *{Path To Dll}* | This is the path to the dll. The dll must match the architecture of the OS. |
| SOFTWARE\Classes\CLSID\<CLSID>\InProcServer32 | ThreadingModel  | Apartment | REG_SZ |
| SOFTWARE\Classes\CLSID\<CLSID>\InProcServer32 | LoadWithoutCOM  |   | REG_SZ, but leave as empty string |
| SOFTWARE\Classes\CLSID\<CLSID>\ShellFolder  |	  	  	 
| SOFTWARE\Classes\CLSID\<CLSID>\ShellFolder  | HideOnDesktop | | REG_SZ, but leave as empty string |
| SOFTWARE\Classes\CLSID\<CLSID>\ShellFolder  | Attributes  | 0xf090013d (4035969341) | REG_DWORD |


<br><br>
Next, create a junction folder in a directory that is navigated on logon. A good location on Windows 8/8.1 is the start menu (especially since there in no classic start menu).

 

C:\Users\{User}\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Accessories\{MyFolder}.{CLSID}

 

Example of Junction Folder creation:

mkdir (CreateDirectory) C:\Users\{User}\Appdata\Roaming\Microsoft\Windows\Start Menu\Programs\Accessories\Indexing.{26A81239-BD1F-48E3-BED4-EB313CFCB041} where {26A81239-BD1F-48E3-BED4-EB313CFCB041} is the CLSID used in the registry entries. 

Also make sure you make the registry entries before you create the junction folder to avoid caching issues with initial launch.
  
The end.
