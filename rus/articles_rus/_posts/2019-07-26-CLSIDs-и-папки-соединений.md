---
title: CLSIDs и Соединительные Папки
layout: post
tags:
  - articles_rus
  - windows
published: true
---

# Оглавление
{:.no_toc}

* toc
{:toc}

# Соединительные папки

Соединительная папка в Windows - это метод, при котором пользователь может вызвать перенаправление в другую папку, обычно в другую известную папку. Соединительная папка считается жесткой ссылкой. Существует несколько способов создания соединительных папок. Модификация реестра может повлечь за собой создание такой папки. Другой способ - это запись desktop.ini внутри папки. Третий, и, вероятно, самый полезный для нас, это метод который является только соглашением об именах. Метод заключается в том, чтобы просто создать папку как таковую. MyFolder.{CLSID папки, с которой вы хотите "соединиться"}. После того как вы назвали папку таким образом, двойной щелчок по ней приведет вас к известной папке, представленной CLSID. Microsoft дает вам много примеров работы такого подхода. Таким образом, вы можете легко создать папку которая "соединяется" с "Панелью управления (все задачи)" и называть ее "Моя панель управления". Вы также можете применять эту технику к изображениями, документам, Internet Explorer, Мой Компьютер. Все эти специальные папки были назначены уникальные CLSID. Смотреть в CLSID установленные по умолчанию в Windows. Ниже приведен пример папки подключения к "Панели управления (все задачи)". Кроме того, если вы не знакомы с CLSID, см. [Что такое ключ реестра CLSID]({{ site.baseurl }}/rus/articles_rus/что-такое-ключ-регистра-clsid/)


![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-6.png){:class="imgsquire"}


Имя папки "My Control Panel".{ED7BA470-8E54-465E-825C-99712043E01C} для перехода к панели управления.

![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-68.png){:class="imgsquire"}

![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-64.png){:class="imgsquire"}



Windows достаточно удобно скроет CLSID для вас.

![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-1.png){:class="imghalf"}

Соединение работает!
<br>

И что? 

Что происходит, когда CLSID не соответствует ожидаемым папкам? Что если это вообще не папка? Вот где это становится немного интересным.


# CLSIDs и COM Объекты

Используя CreateGuid я сгенерировал новый GUID {24138469-5DDA-479D-A150-3695B9365DC0}.  

![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-2.png){:class="imgsquire"}

добавьте CLSID, и мы получим это.

![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-3.png){:class="imgsquire"}
<br>
CLSID не становится скрытым, если не с чем его соотнести. Когда вы перемещаетесь в папку, она выглядит как обычная папка. Однако, если вы посмотрите Procmon, вы увидите это:

![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-7.png){:class="img"}

Из информации Procmon вы можете видеть, что навигация внутри папки заставляет проводник искать этот CLSID в HKEY_CURRENT_USER. По умолчанию подавляющее большинство CLSID хранятся в HKEY_LOCAL_MACHINE, но CLSID в HKEY_CURRENT_USER могут все еще использоваться. Итак, теперь давайте настроим наш ключ.

<br><br>
До:<br>
![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-9.png){:class="imgsquire"}

Добавленны записи:
По умолчанию, {24138469-5DDA-479D-A150-3695B9365DC0} - это ключ имени COM объекта:<br>
![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-11.png){:class="imghalf"}

Значения ключа InProcServer32:<br>
![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-12.png){:class="imghalf"}

Теперь, когда мы перемещаемся в нашей соединительной папке, мы видим:
Значения ключа InProcServer32:
![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-13.png){:class="imghalf"}
<br><br>
Выполнение происходит, когда verclsid.exe вызывает присоединение процесса на нашей DLL. Найс.

# Закрепление на уровне пользователя
К сожалению, похоже что это больше механизм закрепления в системе, чем вектор выполнения кода. Главным образом, потому что это потребовало бы и записи реестра и навигации в соединенительной папке. Рассматривая его как механизм закрепления, все что нам нужно сделать это установить ключи реестра и создать папку соединения в месте, в которое (или в дочернюю папку) проводник (или другой пользовательский процесс) будет перемещаться при запуске. Желательно, чтобы проводник перемещался в соеденительную папку. Мы так же могли бы сделать это с помощью библиотечных файлов в Windows 7+ (смотреть [Windows Library Files In Execution]({{ site.baseurl }}/articles/Windows-Library-Files-In-Execution/)). Для более широкого охвата, используя ту же технику, я в конечном итоге заглянул в папки в которых находилось меню "Пуск". Они загружаются в начале, уже существуют в AppData и их чаще всего просматривают через меню "Пуск".

Итак, перейдите в `%appdata%\\Microsoft\\Windows\\Start Menu` и вы должны увидеть каталоги под меню "Пуск". Тем не менее вы должны быть осторожны при изменении любой из этих папок, так как они часто комбинируются с папками в другом месте для меню "Пуск", и это может быть предупреждением если в меню «Пуск» цели есть две папки с одним и тем же именем. При желании вы также можете создать новую папку вместо уже существующей. В общем, возьмем что-то вроде папки "Accessories".

![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-14.png){:class="imghalf"}


Запустим команду как показано ниже чтобы изменить папку на соединенительную папку (используйте Windows API, если кодите).


![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-15.png){:class="imghalf"}


И обратите внимание, что при перезагрузке снова запускается verclsid.exe.


![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-22.png)
{:class="imghalf"}


# Сохранение Dll как Exe - Windows Run

Это еще не отработанный метод, и в настоящее время он находится на стадии проверки концепции.

В настоящее время существует набор выбора CLSID (еще предстоит определить, чем именно они отличаются - пока что думю, что необходимы дополнительные записи в реестре), к которым можно получить доступ через cmd или Windows -> run. Синтаксис выглядит примерно так:


![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-16.png)
{:class="imghalf"}


или


![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-17.png)
{:class="imghalf"}



Эти примеры открывают папку «Мои документы» в проводнике Windows. Однако, если сделаны правильные записи это может помочь нам повторно использовать техники закрепления exe для dll.


# Папки быстрого доступа + Соеденительные папки + Библиотеки + Файлы ссылок = Эксплуатация 

Давайте объеденим и испольхуем эти находки. Для некоторой теории по библиотекам можно глянуть [Windows Library Files In Execution]({{ site.baseurl }}/articles/Windows-Library-Files-In-Execution/).

В общем, если у нас есть эксплоит файла ссылок, мы бы хотели его скрыть. Мы также знаем из экпериментов с CLSID и соединительными папками, что мы можем принудительно изменить навигацию соединительной папки (достаточно обработки файла чтобы заставить её загрузить DLL, если CLSID находится в реестре). Еще одна приятная вещь библиотеках заключается в том, что они могут выглядеть очень похоже на каталог и продолжать обработку, даже если внешний вид проводника был изменён во время рендеринга. Мы объединим некоторые из этих вещей с техникой, в которой desktop.ini версия соединительной папки используется для запуска рендеринга файла ссылок. Это приводит нас к уникальному CLSID ({0AFACED1-E828-11D1-9187-B532F1E9575D}), который является CLSID для "папки быстрого доступа". Так что же происходит, когда вы соединительную папку MyFolder.{0AFACED1-E828-11D1-9187-B532F1E9575D}? Итак, Microsoft разработала Shortcut Folders (Папки быстрого доступа), цели которой храняться в файле target.lnk, прямо под соединительной папкой. При перемещении по соединительной папке файл ссылки обрабатывается и срабатывает выполнение. Комбинация векторов означает, что в каталоге в который перемещается цель виден только файл библиотеки, а все остальные папки/файлы могут быть скрытыми. 

# Закрепление в проводнике с использованием соединительных папок и шелла (пошаговое руководство

Если вы не хотите закрепления с помощью verclsid, вы можете добавить пару дополнительных записей для уверенности что вас загружает Проводник. Чтобы настроить эту технику закрепления, вы должны:
 
Установите следующие ключи реестра в HKEY_LOCAL_MACHINE или HKEY_CURRENT_USER (с учетом 64-битных и 32-битных реестров):



Создать:

| Ключ           | Имя          | Значение         | Заметка         |
| :---------------------------------- | :-----------  | :-----------  | :-----------  |
| SOFTWARE\Classes\CLSID  | | | Оно не всегда создается в HKEY_CURRENT_USER |
| SOFTWARE\Classes\CLSID\<CLSID>  | | | Создай свою CLSID, ф не ту что уже используется в системе |
| SOFTWARE\Classes\CLSID\<CLSID>  |(Дефолтное)| Имя класса |Это опционально. У многих классов есть имена |  	 
| SOFTWARE\Classes\CLSID\<CLSID>\InProcServer32                                   
|
| SOFTWARE\Classes\CLSID\<CLSID>\InProcServer32 | (Дефолтное) | *{Путь до DLL}* | Это путь до DLL. DLL должна соответствовать архитектуре ОС. |
| SOFTWARE\Classes\CLSID\<CLSID>\InProcServer32 | Threading Model  | Apartment | REG_SZ |
| SOFTWARE\Classes\CLSID\<CLSID>\InProcServer32 | LoadWithoutCOM  |   | REG_SZ, но оставь как пустую строку |
| SOFTWARE\Classes\CLSID\<CLSID>\ShellFolder  |	  	  	 
| SOFTWARE\Classes\CLSID\<CLSID>\ShellFolder  | HideOnDesktop | | REG_SZ, но оставь как пустую строку|
| SOFTWARE\Classes\CLSID\<CLSID>\ShellFolder  | Attributes  | 0xf090013d (4035969341) | REG_DWORD |


<br><br>
Затем, создайте соединительную папку в каталоге в который осуществляется переход при входе в систему. Хорошее место в Windows 8/8.1 - это меню "Пуск" (тем более что классического меню "Пуск" больше нет).

 

C:\Users\{User}\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Accessories\{МояПапка}.{CLSID}

 

Примеры создания соединительной папки:

mkdir (CreateDirectory) C:\Users\{User}\Appdata\Roaming\Microsoft\Windows\Start Menu\Programs\Accessories\Indexing.{26A81239-BD1F-48E3-BED4-EB313CFCB041} где {26A81239-BD1F-48E3-BED4-EB313CFCB041} это CLSID которое используется в записях реестра. 

Также убедитесь, что вы делаете записи реестра __перед__ созданием соединительной папки, чтобы избежать проблем с кэшированием при первом запуске.
