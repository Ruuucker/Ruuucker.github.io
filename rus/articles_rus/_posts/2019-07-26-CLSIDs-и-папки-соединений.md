---
title: CLSIDs и Соединительные Папки
layout: post
tags:
  - articles_rus
  - windows
published: true
---

# Оглавление
{:.no_toc}

* toc
{:toc}

# Соединительные папки

Соединительная папка в Windows - это метод, при котором пользователь может вызвать перенаправление в другую папку, обычно в другую известную папку. Соединительная папка считается жесткой ссылкой. Существует несколько способов создания соединительных папок. Модификация реестра может повлечь за собой создание такой папки. Другой способ - это запись desktop.ini внутри папки. Третий, и, вероятно, самый полезный для нас, это метод который является только соглашением об именах. Метод заключается в том, чтобы просто создать папку как таковую. MyFolder.{CLSID папки, с которой вы хотите "соединиться"}. После того как вы назвали папку таким образом, двойной щелчок по ней приведет вас к известной папке, представленной CLSID. Microsoft дает вам много примеров работы такого подхода. Таким образом, вы можете легко создать папку которая "соединяется" с "Панелью управления (все задачи)" и называть ее "Моя панель управления". Вы также можете применять эту технику к изображениями, документам, Internet Explorer, Мой Компьютер. Все эти специальные папки были назначены уникальные CLSID. Смотреть в CLSID установленные по умолчанию в Windows. Ниже приведен пример папки подключения к "Панели управления (все задачи)". Кроме того, если вы не знакомы с CLSID, см. [Что такое ключ реестра CLSID]({{ site.baseurl }}/articles/What-is-a-CLSID-Registry-Key/ "What is a CLSID Registry Key")


![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-6.png){:class="imgsquire"}


Имя папки "My Control Panel".{ED7BA470-8E54-465E-825C-99712043E01C} для перехода к панели управления.

![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-68.png){:class="imgsquire"}

![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-64.png){:class="imgsquire"}



Windows достаточно удобно скроет CLSID для вас.

![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-1.png){:class="imghalf"}

Соединение работает!
<br>

И что? 

Что происходит, когда CLSID не соответствует ожидаемым папкам? Что если это вообще не папка? Вот где это становится немного интересным.


# CLSIDs и COM Объекты

Используя CreateGuid я сгенерировал новый GUID {24138469-5DDA-479D-A150-3695B9365DC0}.  

![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-2.png){:class="imgsquire"}

добавьте CLSID, и мы получим это.

![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-3.png){:class="imgsquire"}
<br>
CLSID не становится скрытым, если не с чем его соотнести. Когда вы перемещаетесь в папку, она выглядит как обычная папка. Однако, если вы посмотрите Procmon, вы увидите это:

![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-7.png){:class="img"}

Из информации Procmon вы можете видеть, что навигация внутри папки заставляет проводник искать этот CLSID в HKEY_CURRENT_USER. По умолчанию подавляющее большинство CLSID хранятся в HKEY_LOCAL_MACHINE, но CLSID в HKEY_CURRENT_USER могут все еще использоваться. Итак, теперь давайте настроим наш ключ.

<br><br>
До:<br>
![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-9.png){:class="imgsquire"}

Добавленны записи:
По умолчанию, {24138469-5DDA-479D-A150-3695B9365DC0} - это ключ имени COM объекта:<br>
![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-11.png){:class="imghalf"}

Значения ключа InProcServer32:<br>
![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-12.png){:class="imghalf"}

Теперь, когда мы перемещаемся в нашей соединительной папке, мы видим:
Значения ключа InProcServer32:
![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-13.png){:class="imghalf"}
<br><br>
Выполнение происходит, когда verclsid.exe вызывает присоединение процесса на нашей DLL. Найс.

# Закрепление на уровне пользователя
К сожалению, похоже что это больше механизм закрепления в системе, чем вектор выполнения кода. Главным образом, потому что это потребовало бы и записи реестра и навигации в соединенительной папке. Рассматривая его как механизм закрепления, все что нам нужно сделать это установить ключи реестра и создать папку соединения в месте, в которое (или в дочернюю папку) проводник (или другой пользовательский процесс) будет перемещаться при запуске. Желательно, чтобы проводник перемещался в соеденительную папку. Мы так же могли бы сделать это с помощью библиотечных файлов в Windows 7+ (смотреть [Windows Library Files In Execution]({{ site.baseurl }}/articles/Windows-Library-Files-In-Execution/)). Для более широкого охвата, используя ту же технику, я в конечном итоге заглянул в папки в которых находилось меню "Пуск". Они загружаются в начале, уже существуют в AppData и их чаще всего просматривают через меню "Пуск".

Итак, перейдите в `%appdata%\\Microsoft\\Windows\\Start Menu` и вы должны увидеть каталоги под меню "Пуск". Тем не менее вы должны быть осторожны при изменении любой из этих папок, так как они часто комбинируются с папками в другом месте для меню "Пуск", и это может быть предупреждением если в меню «Пуск» цели есть две папки с одним и тем же именем. При желании вы также можете создать новую папку вместо уже существующей. В общем, возьмем что-то вроде папки "Accessories".

![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-14.png){:class="imghalf"}


Запустим команду как показано ниже чтобы изменить папку на соединенительную папку (используйте Windows API, если кодите).


![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-15.png){:class="imghalf"}


И обратите внимание, что при перезагрузке снова запускается verclsid.exe.


![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-22.png)
{:class="imghalf"}


# Сохранение Dll как Exe - Windows Run

Это еще не отработанный метод, и в настоящее время он находится на стадии проверки концепции.

В настоящее время существует набор выбора CLSID (еще предстоит определить, чем именно они отличаются - пока что думю, что необходимы дополнительные записи в реестре), к которым можно получить доступ через cmd или Windows -> run. Синтаксис выглядит примерно так:


![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-16.png)
{:class="imghalf"}


или


![1]({{ site.baseurl }}/assets/img/posts/CLSIDs and Junction Folders/image2014-10-17.png)
{:class="imghalf"}



Эти примеры открывают папку «Мои документы» в проводнике Windows. Однако, если сделаны правильные записи это может помочь нам повторно использовать техники закрепления exe для dll.


# Папки быстрого доступа + Соеденительные папки + Библиотеки + Файлы ссылок = Эксплуатация 

Давайте объеденим и испольхуем эти находки. Для некоторой теории по библиотекам можно глянуть [Windows Library Files In Execution]({{ site.baseurl }}/articles/Windows-Library-Files-In-Execution/).

В общем, если у нас есть эксплоит файла ссылок, мы бы хотели его скрыть. Мы также знаем из экпериментов с CLSID и соединительными папками, что мы можем принудительно изменить навигацию соединительной папки (достаточно рендеринга чтобы заставить её загрузить DLL, если CLSID находится в реестре). Еще одна приятная вещь библиотеках заключается в том, что они могут выглядеть очень похоже на каталог и продолжать рендеринг, даже если внешний вид проводника был изменён во время рендеринга. Мы объединим некоторые из этих вещей с техникой, в которой desktop.ini версия соединительной папки используется для запуска рендеринга файла ссылок. Это вызвало очень уникальный CLSID ({0AFACED1-E828-11D1-9187-B532F1E9575D}), который является CLSID для "папки быстрого доступа". Так что же происходит, когда вы создаете соединение, MyFolder. {0AFACED1-E828-11D1-9187-B532F1E9575D}? Итак, Microsoft разработала Shortcut Folders для хранения своей цели в файле target.lnk непосредственно под папкой Junction. При перемещении по папке Junction файл ссылки обрабатывается и выполняется выполнение. Комбинация означает, что в каталоге, к которому перемещается цель, виден только библиотечный файл, а все остальные папки / файлы могут быть скрытыми в системе. Не используйте технику без файлов библиотеки, если не предоставлено разрешение. Мы не хотим появляться слишком близко к технике TAO.

We'll combine some of these things with a technique used by TAO in which a desktop.ini version of the junction folder is used to kick off the rendering of the link file. This brought up a very unique CLSID ({0AFACED1-E828-11D1-9187-B532F1E9575D}) which is the CLSID for a "Shortcut Folder". So what happens when you create the junction, MyFolder.{0AFACED1-E828-11D1-9187-B532F1E9575D}? Well, Microsoft designed Shortcut Folders to store its target in a target.lnk file directly below the junction folder. When the junction folder is navigated, the link file is rendered and execution is gained. The combination means that only the library file is visible in the directory the target navigates to, and all the other folders/file can be system, hidden. Do not use the technique without the library files unless permission is granted. We don't want to appear too close to TAO's technique. 

# Persisting in Explorer Using Junctions and Shell Folders (Walk-Through)

If you don't wish to be persisted by verclsid, you can add a couple extra entries to make sure that it is explorer that loads you instead. To setup this persistence technique you must:

 

Set the following registry keys in either HKEY_LOCAL_MACHINE or HKEY_CURRENT_USER (keeping in mind 64-bit and 32-bit registries):





Create:

| Key           | Name          | Value         | Notes         |
| :---------------------------------- | :-----------  | :-----------  | :-----------  |
| SOFTWARE\Classes\CLSID  | | | This has not always been created in HKEY_CURRENT_USER |
| SOFTWARE\Classes\CLSID\<CLSID>  | | | Create your own CLSID, not one that is already being used on the system |
| SOFTWARE\Classes\CLSID\<CLSID>  |(Default)| Name of Class |This is optional. Many classes have names |  	 
| SOFTWARE\Classes\CLSID\<CLSID>\InProcServer32                                   
|
| SOFTWARE\Classes\CLSID\<CLSID>\InProcServer32 | (Default) | *{Path To Dll}* | This is the path to the dll. The dll must match the architecture of the OS. |
| SOFTWARE\Classes\CLSID\<CLSID>\InProcServer32 | ThreadingModel  | Apartment | REG_SZ |
| SOFTWARE\Classes\CLSID\<CLSID>\InProcServer32 | LoadWithoutCOM  |   | REG_SZ, but leave as empty string |
| SOFTWARE\Classes\CLSID\<CLSID>\ShellFolder  |	  	  	 
| SOFTWARE\Classes\CLSID\<CLSID>\ShellFolder  | HideOnDesktop | | REG_SZ, but leave as empty string |
| SOFTWARE\Classes\CLSID\<CLSID>\ShellFolder  | Attributes  | 0xf090013d (4035969341) | REG_DWORD |


<br><br>
Next, create a junction folder in a directory that is navigated on logon. A good location on Windows 8/8.1 is the start menu (especially since there in no classic start menu).

 

C:\Users\{User}\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Accessories\{MyFolder}.{CLSID}

 

Example of Junction Folder creation:

mkdir (CreateDirectory) C:\Users\{User}\Appdata\Roaming\Microsoft\Windows\Start Menu\Programs\Accessories\Indexing.{26A81239-BD1F-48E3-BED4-EB313CFCB041} where {26A81239-BD1F-48E3-BED4-EB313CFCB041} is the CLSID used in the registry entries. 

Also make sure you make the registry entries before you create the junction folder to avoid caching issues with initial launch.
  
The end.
