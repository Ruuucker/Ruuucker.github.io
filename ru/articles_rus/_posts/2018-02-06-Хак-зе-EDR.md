---
layout: post
categories: articles
tags:
  - ru
  - edr
  - common
published: true
ru: true
---

# Оглавление
{:.no_toc}

* toc
{:toc}

# Минимальная теория
EDR - Endpoint Detection and Response.
Имеет серверную часть обычно для управления и сбора логов событий с машин на которых установлен агент. И агента который устанавливается на конечные машины.
Если серверная часть не сильно отличается от общеизвестных вещей которые мы привыкли видеть в других технологиях, то на агенте стоит остановиться поподробнее.
Как и некоторые AV системы, EDR агенты могут управлять действиями пользователя с помощью WinAPI хуков, что это такое можно описать в отдельной статье, так что просто опишу их как ловушки которые срабатывают в момент вызовов API для OS Windows с помошью которых можно перехватывать вызов определенной функции и перенаправлять на другой код который более выгоден тому, кто поставил хук или ловушку, более подробно по WinAPI на [Вики](https://ru.wikipedia.org/wiki/Windows_API) или [Хабре](https://habr.com/ru/post/352096/). И про сами Хуки на том же [Хабре](https://habr.com/ru/company/icl_services/blog/324718/) или [Хакере](https://xakep.ru/2018/01/26/winapi-hooks/).

Итак, EDR агенты ставят эти хуки в определенные функции тем самым внедряя свой код проверки, можно ли вызывать эту функцию, и если нет то возвращают ошибку в противном случае просто пропускают функцию на выполнение.

Пример, мы хотим запустит злой файл. Для запуска злого файла нам нужен новый процесс который создается с помощью WinAPI функции NtCreateUserProcess. EDR агент поставил на эту функцию ловушку или хук и каждый раз когда мы запускаем что-то с помощью NtCreateUserProcess мы попадаемся в эту ловушку. В ловушке EDR агент проверяет какой процесс мы хоти создать и если он злой, то запретит это сделать а если легимитивный то разрешит, таким образом контролируя действия пользователя или программы.

# Рекон
Первым делом определяем есть ли на точке EDR, в этом помогает:

1) Листинг процессов, тут всё понятно
2) Брать цифровую подпись драйверов ядра и сравнение оных с известными сигнатурами вендоров, вот тулза для таких [вещей] (https://gist.github.com/jthuraisamy/4c4c751df09f83d3620013f5d370d3b9)

Так же при приземлении на точке нужно не только понять что за EDR тут запущена, но и как она сконфигурирована, для этого нужно искать конфиг путь к которому обычно есть в документации к этому продукту, так же нужно оттуда почерпнуть как разшифровать его, если он зашифрован.

# Разбираемся с потоком телеметрии

Общие вопросы на которые стоит ответить прежде чем предпринимать действия.
~~~
1) Кэшируется ли телеметрия на диск или в память?
2) Если это на диске, это может быть БД, файл временного кэша или «безфайловый»?
3) Если в памяти, насколько возможно извлечь из неё всё и написать фиктивный сервер?
4) Предлагает ли продукт диагностический механизм для запроса телеметрии?
5) Нужно ли расшифровывать или деобфусировать буферы перед десериализацией?
6) Как они сериализуются (например, ProtoBuf, JSON, Bond, custom)?
7) Доступны ли схемы для типов событий? Если нет, можно ли их восстановить?
8) Могу ли я убить каким-либо образом процесс передачи телеметрии?
~~~
Обычно бывают 2 сценария

1) Телеметрия записывается где-то в долгой памяти ПК либо кешируется и сервер забирает данные в интервале, либо хранится в оперативке
  В этом случае можно попробовать получить доступ к этим данным, возможно их метоположение будет в документации и возможно они будут защифрованны, а еще сама EDR может тригернуться на попытку получить доступ к данным не из положенного процесса, так что это опасный путь с минами.
  После получения этих данных их предстоит распарсить, либо это будут ProtoBuf [https://developers.google.com/protocol-buffers] с тулзой [https://github.com/mildsunrise/protobuf-inspector] или JSON.
  Так же схемы восстановления данных могут быть найдены онлайн [https://github.com/carbonblack/cbapi/blob/master/server_apis/proto/sensor_events.proto], либо сделать вот так (я не понял как) [http://jackson-t.ca/protobuf-recovery.html], либо в документашке либо вот в проекте OSSEM [https://github.com/hunters-forge/OSSEM/tree/master/data_dictionaries/windows]. Но чет тут я теряюсь и не могу кристально чисто ответить на многие вопросы.
  После сохранения файла за ним приходит сервер и после ответа 200 файл удаляется. Но его дескриптор всё еще доступен и может быть вытащен [https://github.com/marin-m/pbtk] если это протобаф.

2) Телеметрия идет непрерывным потоком на сервер с помощью Веб сокетов.
Если можно изменить хоть что нибудь через конфиг касающегося сокетов, стоит попробовать. В зависимости от этого можно либо пробовать отключить шифр\сменить удаленный сервер\что нибудь похожее либо пробовать ставить прокси, смотреть на трафик и скорее всего забивать, потому что там TSL. Тут очень много зависит от конфига, потому что в теории мы можем поставить на точку заглушку для сервера, но вот настоящий клиент не угомонится если мы не направим его праведный гнев в другое русло.

# Что делать с ограничениями?

## Просто обойти
Во первых нужно определить, что именно блокируется. Если есть возможность поставить что-то вроде API Monitor то очень полезно будет определить какие именно вызовы попадают под черный список и плясать от этого, находя аналогичный эффект в других вызовах. Как например запуск кода можно реализовать не только методом NtCreateUserProcess, но и классическими приёмами Process Injection. Либо же пользоваться родными бинарниками системы для достижения своих целей, как например использование msbuild или mshta которые могут исполнять код. Полный список полезных бинарников представлен здесь для [Windows](https://lolbas-project.github.io/) и здесь для [Linux](https://gtfobins.github.io/). 

## Снять
Если хуки установленны в DLL с помощью EDR которая запускается в юзермоде как и мы, почему у неё должно быть больше прав чем у нас? Мы можем взять и очистить все функции тем самым снимем ограничения на наше пользование, например этим [рефрешером](https://github.com/CylanceVulnResearch/ReflectiveDLLRefresher).
Но может быть и так что EDR запускается как драйвер с правами системы (скорее всего так и будет) и поэтому подобные трюки не пройдут.

## Написать собственные функции
А почему бы и нет? Берем и пишем на асме низкоуровненые аналоги NtOpenProcess, используем их в собственном коде и дампим lsass в обход каких-либо ограничений, вот пример [https://github.com/outflanknl/Dumpert].
То же самое можно проделать с помощью любой функции, но тут скрываются трудности.
Во первых, подобные прямые системные вызовы (сис колы) разняться от версии к версии (сейчас я говорю исключительно про Windows). Так как документированные WinAPI являются надстройкой над недокументированными прямыми сис колами, будет сложно определить как именно и в какой версии нужно реализовывать ту или иную функцию, документации ведь нет!

К счастью, существует 2 ресурса призванные к этом помочь:
1) Список сис колов которые используются в WinAPI функциях [бах](https://j00ru.vexillium.org/syscalls/nt/64/)
2) Готовая кросс версионная библиотека для Windows [SysWhispers](https://github.com/jthuraisamy/SysWhispers)


# Ссылки
Или свалка информации для дальнейшего чтения и углубления к эту тему, материала ОЧЕНЬ много и у каждой статьи в конце есть ЕЩЕ по 5 статей которые тоже имеют по 5 статей в ссылках, поэтому читать можно долго и обстоятельно.

[Очищение EDR хуков](https://blogs.blackberry.com/en/2017/02/universal-unhooking-blinding-security-software)

[Общее описание EDR систем вместе с телеметрией, сервером и прочими вещами, часть информации уже описана в данной статье но там такого больше](http://jackson-t.ca/)

[Описание защитных механизмов EDR и почему сисколы работают, от автора Dumpert](https://outflank.nl/blog/2019/06/19/red-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr/)

Мониторинг WinAPI вызовов и иньекций кода в юзерленде, не совсем по теме но тоже интересно. [хъ](https://0x00sec.org/t/userland-api-monitoring-and-code-injection-detection/5565)

[Практические примеры обхода Cylance](https://www.mdsec.co.uk/2019/03/silencing-cylance-a-case-study-in-modern-edrs/)

[Попытка запустить](https://forensicitguy.github.io/posts/linux-edr-evasion-with-ld-preload/) meterpreter в обход EDR
